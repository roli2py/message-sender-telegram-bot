@startuml classDiagram
class None <<primitive>>
interface Sender {
    + send(data: String): None
}
class EmailSender {
    - smtp: SMTP
    - from_addr: String
    - to_addr: String
    - sender_name: String
    + EmailSender(smpt: SMTP, from_addr: String, to_addr: String, sender_name: String [0..1])
    + get_sender_name(): String
    + set_sender_name(sender_name: String): None
    + send(data: String): None
}
class SMTP
interface SMTPCreator {
    + create(): SMTP
}
class GmailSMTPCreator {
    - login: String
    - password: String
    + GmailSMTPCreator(login: String, password: String)
}
class set<T>
interface Authorization {
    + authorize(): Boolean
}
class TokenAuthorization<TokenType : Token> {
    - valid_tokens: set<TokenType>
    - token: TokenType
    + TokenAuthorization(valid_tokens: set<TokenType>, token: TokenType)
    + authorize(): Boolean
}
interface Token {
    + get(): String
}
class HexToken {
    - token: String
    + HexToken(token: String)
    + get(): String
}
interface TokenGenerator {
    + create(): Token
}
class HexTokenGenerator {
    + create(): Token
}
class DeclarativeBase
class Base
class ValidToken {
    + __tablename__: String = "valid_token"
    + id_: Mapped<UUID>
    + token: Mapped<String>
}
class User {
    + __tablename__: String = "user"
    + id_: Mapped<UUID>
    + user_id: Mapped<Integer>
    + token: Mapped<String> [0..1]
    + is_authorizing: Mapped<Boolean>
}
class Mapped<T>
class UUID
class Session
interface DBItemGetter {
    + get(): Base [0..1]
}
interface DBItemCreator {
    + create(): Base
}
interface AbstractDBUserManipulator {
    + get(): User [0..1]
    + create(): User
    + get_authorizing_status(): Boolean
    + get_valid_token(): ValidToken [0..1]
    + set_authorizing_status(is_authorizing: Boolean): None
    + set_valid_token(valid_token: ValidToken): None
    + clear_valid_token(): None
    + get_owner_status(): Boolean
}
class DBUserManipulator {
    - db_session: Session
    - user_id: Integer [0..1]
    - db_user: User [0..1]
    + DBUserManipulator(db_session: Session, user_id: Integer = None, db_user: User = None)
    + get(): User [0..1]
    + create(): User
    + get_authorizing_status(): Boolean
    + get_valid_token(): ValidToken [0..1]
    + set_authorizing_status(is_authorizing: Boolean): None
    + set_valid_token(valid_token: ValidToken): None
    + clear_valid_token(): None
    + get_owner_status(): Boolean
}
class DBValidTokenManipulator {
    - db_session: Session
    - token: String
    + DBValidTokenManipulator(db_session: Session, token: String)
    + get(): ValidToken [0..1]
    + create(): ValidToken
}
interface OwnershipProver {
    + prove(): Boolean
}
class UserOwnershipProver {
    - db_user_manipulator: AbstractDBUserManipulator
    + UserOwnershipProver(db_user_manipulator: AbstractDBUserManipulator)
    + prove(): Boolean
}
class datetime
class timedelta
interface CooldownChecker {
    + is_pass(): Boolean
}
class MessageSendCooldownChecker {
    - last_send_date: datetime
    - cooldown: timedelta [0..1]
    - pass_date: datetime [0..1]
    + MessageSendCooldownChecker(last_send_date: datetime, cooldown: timedelta = None, pass_date: datetime = None)
    + is_pass(): Boolean
}
class DBMessageManipulator {
    - db_session: Session
    - message_id: Integer
    - sender: User [0..1]
    - text: String [0..1]
    + DBMessageManipulator(db_session: Session, message_id: Integer, sender: User = None, text: String = None)
    + get(): Message [0..1]
    + create(): Message
}

note left of None
    Indicating a lack of the value
endnote
note left of SMTP
    An `SMTP` class from
    a `smtplib` standard library
endnote
note left of set
    An Python's unordered
    collection of distinct
    hashable objects.

    T â€” Value Type
endnote
note right of DeclarativeBase
    A SQLAlchemy's class
    which needs to be inherited
    to make a base for a
    declarative mapping
endnote
note right of Mapped
    A SQLAlchemy's class
    that represents a database
    column type
endnote
note right of UUID
    A Python's UUID class
endnote
note left of Session
    A SQLAlchemy's class
    that provides a control
    of the database tables
    by the ORM classes
endnote
note right of DBUserManipulator::DBUserManipulator
    There is no reason to
    supply both user ID and
    DB user, because the
    class creates a DB user
    from a user ID or a
    client directly provides
    a DB user; so the
    client must provide
    either a user ID or a DB
    user
endnote
note right of datetime
    A `datetime` library's
    class that represents a
    date with time
endnote
note left of timedelta
    A `datetime` library's
    class that represents a
    difference between two
    `datetime` objects
endnote
note right of MessageSendCooldownChecker::MessageSendCooldownChecker
    A client can choose to
    provide a cooldown or a
    specific date when a user
    will get an access
endnote

None <-- Sender
Sender <|.. EmailSender
EmailSender o-- SMTP
SMTP <-- SMTPCreator
SMTPCreator <|.. GmailSMTPCreator
Authorization <|.. TokenAuthorization
set <-- TokenAuthorization
Token <-- TokenAuthorization
Token <|.. HexToken
TokenGenerator <|.. HexTokenGenerator
Token <-- TokenGenerator
Token <-- HexTokenGenerator
DeclarativeBase <|-- Base
Base <|-- ValidToken
Base <|-- User
Mapped <-- ValidToken
UUID <-- ValidToken
Mapped <-- User
UUID <-- User
DBItemGetter <|-- AbstractDBUserManipulator
DBItemCreator <|-- AbstractDBUserManipulator
AbstractDBUserManipulator <|.. DBUserManipulator
Session <-- DBUserManipulator
DBItemGetter <|.. DBValidTokenManipulator
DBItemCreator <|.. DBValidTokenManipulator
OwnershipProver <|.. UserOwnershipProver
CooldownChecker <|.. MessageSendCooldownChecker
datetime <-- MessageSendCooldownChecker
timedelta <-- MessageSendCooldownChecker
DBItemGetter <|-- DBMessageManipulator
DBItemCreator <|-- DBMessageManipulator
@enduml
